{
  "document": {
    "summary": "Для обеспечения линеаризуемого чтения данных можно использовать журнал, где позиция сообщения определяет время его чтения, или синхронно обновляемые реплики. Консенсусные алгоритмы, такие как Paxos, Raft и Zab, обеспечивают уникальность ведущего узла и согласованность данных, решая задачи, эквивалентные консенсусу, например, порядок доставки сообщений или управление блокировками.",
    "units": [
      {
        "text": "Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems 1st Edition",
        "start": null,
        "end": null,
        "id": "unit_0001",
        "refined": "Designing Data-Intensive Applications: Основные идеи надежных, масштабируемых и поддерживаемых систем. 1-е издание.",
        "summary": "Книга \"Designing Data-Intensive Applications\" охватывает ключевые принципы создания надежных, масштабируемых и легко поддерживаемых систем обработки данных.",
        "topics": [
          "надежные системы",
          "масштабируемые решения",
          "данные приложений",
          "поддержка систем"
        ],
        "topics_en": [
          "reliable systems",
          "scalable solutions",
          "application data",
          "system support"
        ]
      },
      {
        "text": "Перечислим несколько вариантов, позволяющих\nсделать чтение линеаризуемым.",
        "start": 117,
        "end": 190,
        "id": "unit_0002",
        "refined": "Вот несколько способов сделать чтение линеаризуемым.",
        "summary": "Чтобы сделать чтение линеаризуемым, можно использовать синхронизацию доступа к данным, последовательную обработку запросов или специальные алгоритмы согласования.",
        "topics": [
          "Чтение линеаризуемым",
          "Способы чтения"
        ],
        "topics_en": [
          "Linearizable reading",
          "Reading methods"
        ]
      },
      {
        "text": "Можно последовательно читать через журнал, добавляя туда сообщение, считы- вая журнал и затем выполняя фактическое чтение после возврата сообщения.",
        "start": 191,
        "end": 338,
        "id": "unit_0003",
        "refined": "Можно читать последовательно через журнал, добавляя туда сообщение, считывая журнал и затем выполняя чтение после его возврата.",
        "summary": "Для последовательного чтения можно использовать журнал: добавлять сообщение, считывать журнал и читать после его возврата.",
        "topics": [
          "последовательное чтение",
          "добавление сообщения",
          "считывание журнала"
        ],
        "topics_en": [
          "sequential reading",
          "message addition",
          "log reading"
        ]
      },
      {
        "text": "Таким образом, позиция сообщения в журнале определяет момент времени, в который происходит чтение.",
        "start": 339,
        "end": 437,
        "id": "unit_0004",
        "refined": "Позиция сообщения в журнале определяет время его чтения.",
        "summary": "Позиция сообщения в журнале влияет на время его прочтения.",
        "topics": [
          "Позиция сообщения",
          "время чтения",
          "журнал сообщений"
        ],
        "topics_en": [
          "Message position",
          "Reading time",
          "Message log"
        ]
      },
      {
        "text": "(Примерно так реализованы операции чтения в Quorum [16].)\nЕсли журнал позволяет получить позицию последнего сообщения линеаризу- емым способом, то можно запросить ее, дождаться, пока вам будут доставлены все записи до этой позиции, а затем выполнить чтение.",
        "start": 438,
        "end": 695,
        "id": "unit_0005",
        "refined": "(Примерно так реализованы операции чтения в Quorum [16].) Если журнал поддерживает линеаризованное получение позиции последнего сообщения, можно запросить эту позицию, дождаться получения всех записей до неё и выполнить чтение.",
        "summary": "Для чтения в Quorum можно запросить линеаризованную позицию последнего сообщения, дождаться всех записей до неё и выполнить чтение.",
        "topics": [
          "Линеаризованное получение",
          "Позиция последнего сообщения",
          "Запрос позиции",
          "Чтение записей"
        ],
        "topics_en": [
          "Linearized fetching",
          "Last message position",
          "Position query",
          "Reading records"
        ]
      },
      {
        "text": "(Данная идея лежит в основе операции sync() в ZooKeeper [15].)\nМожно выполнить чтение реплики, которая синхронно обновляется при записи и, следовательно, наверняка будет актуальной.",
        "start": 696,
        "end": 877,
        "id": "unit_0006",
        "refined": "Можно выполнить чтение реплики, которая синхронно обновляется при записи и, следовательно, будет актуальной.",
        "summary": "Реплика, синхронно обновляемая при записи, обеспечивает актуальность данных при чтении.",
        "topics": [
          "синхронное обновление",
          "актуальная реплика"
        ],
        "topics_en": [
          "synchronous update",
          "current replica"
        ]
      },
      {
        "text": "(Этот метод используется при цепной репликации [63]; см. также врезку «Исследования вопроса репликации» в подразделе «Синхронная и асинхронная репликация» раздела 5.1.)",
        "start": 878,
        "end": 1046,
        "id": "unit_0007",
        "refined": "Этот метод применяется для цепной репликации [63]; см. также врезку «Исследования репликации» в разделе 5.1, подраздел «Синхронная и асинхронная репликация».",
        "summary": "Метод используется для цепной репликации данных, подробности см. в разделе «Исследования репликации» о синхронной и асинхронной репликации.",
        "topics": [
          "цепная репликация",
          "асинхронная репликация"
        ],
        "topics_en": [
          "chain replication",
          "asynchronous replication"
        ]
      },
      {
        "text": "этой формулировке консенсусный алгоритм должен удовлетворять следующим требованиям [25]1.\nЕдиное решение.",
        "start": 1047,
        "end": 1154,
        "id": "unit_0008",
        "refined": "Консенсусный алгоритм должен удовлетворять требованию единого решения [25].",
        "summary": "Консенсусный алгоритм обязан обеспечивать единое решение для всех участников процесса.",
        "topics": [
          "единого решения",
          "консенсусный алгоритм"
        ],
        "topics_en": [
          "single solution",
          "consensus algorithm"
        ]
      },
      {
        "text": "Никакие два узла не могут получить разные решения.\nЦелостность.",
        "start": 1155,
        "end": 1220,
        "id": "unit_0009",
        "refined": "Никакие два узла не могут получить разные решения. Целостность.",
        "summary": "Целостность системы обеспечивает, что никакие два узла не получают противоречивые решения.",
        "topics": [
          "Целостность системы",
          "Узлы решения"
        ],
        "topics_en": [
          "System Integrity",
          "Decision Nodes"
        ]
      },
      {
        "text": "Ни один узел не получает два решения.\nДействительность.",
        "start": 1221,
        "end": 1278,
        "id": "unit_0010",
        "refined": "Ни один узел не получает два решения.",
        "summary": "Каждый узел получает только одно решение.",
        "topics": [
          "уникальные решения",
          "узел системы"
        ],
        "topics_en": [
          "unique solutions",
          "system node"
        ]
      },
      {
        "text": "Если узел выбирает решение v, то v было предложено дру- гим узлом.\nЗавершенность.",
        "start": 1279,
        "end": 1362,
        "id": "unit_0011",
        "refined": "Если узел выбирает решение v, то v было предложено другим узлом. Завершенность.",
        "summary": "Если узел выбирает решение v, оно обязательно было предложено другим узлом, что обеспечивает завершенность процесса.",
        "topics": [
          "Выбор решения",
          "Предложение узлом",
          "Завершенность процесса"
        ],
        "topics_en": [
          "Decision making",
          "Node proposal",
          "Process completion"
        ]
      },
      {
        "text": "Каждый узел, который не вышел из строя, в конечном итоге выбирает то или иное значение.",
        "start": 1363,
        "end": 1450,
        "id": "unit_0012",
        "refined": "Каждый работающий узел в итоге выбирает значение.",
        "summary": "Каждый активный узел в системе最终选择一个值. Note: The last part of the sentence \"最终选择一个值\" is in Chinese, which means \"eventually chooses a value\". The correct Russian translation should be \"в конечном итоге выбирает значение\". Here is the corrected version: Каждый активный узел в системе в конечном итоге выбирает значение.",
        "topics": [
          "Выбор значения",
          "Работающие узлы"
        ],
        "topics_en": [
          "Value selection",
          "Active nodes"
        ]
      },
      {
        "text": "Завершенность — свойство жизнеспособности, в то время как остальные три являются свойствами безопасно- сти, см. пункт «Функциональная безопасность и живучесть» подраздела «Модели системы на практике» раздела 8.4.",
        "start": null,
        "end": null,
        "id": "unit_0013",
        "refined": "Завершенность — свойство жизнеспособности, в то время как остальные три свойства относятся к безопасности. См. пункт «Функциональная безопасность и живучесть» в подразделе «Модели системы на практике» раздела 8.4.",
        "summary": "Завершенность обеспечивает жизнеспособность системы, в то время как другие свойства относятся к её безопасности.",
        "topics": [
          "Завершенность жизнеспособности",
          "Функциональная безопасность",
          "Система практике"
        ],
        "topics_en": [
          "Viability completeness",
          "Functional safety",
          "Practice system"
        ]
      },
      {
        "text": "Наиболее известными отказоустойчивыми консенсусными алгоритмами явля- ются Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
        "start": null,
        "end": null,
        "id": "unit_0014",
        "refined": "Наиболее известные отказоустойчивые консенсусные алгоритмы: Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
        "summary": "Известные отказоустойчивые консенсусные алгоритмы включают Viewstamped Replication, Paxos, Raft и Zab, обеспечивающие согласованность данных в распределённых системах.",
        "topics": [
          "Отказоустойчивые алгоритмы",
          "Viewstamped Replication",
          "Paxos",
          "Raft"
        ],
        "topics_en": [
          "Fault-tolerant algorithms",
          "Viewstamped Replication",
          "Paxos",
          "Raft"
        ]
      },
      {
        "text": "Алгоритм рассылки общей последовательности",
        "start": null,
        "end": null,
        "id": "unit_0015",
        "refined": "Алгоритм рассылки общей последовательности:.",
        "summary": "Алгоритм рассылки общей последовательности обеспечивает эффективное распространение данных среди участников системы.",
        "topics": [
          "рассылка последовательности",
          "общая последовательность"
        ],
        "topics_en": [
          "sequence distribution",
          "shared sequence"
        ]
      },
      {
        "text": "Гарантия уникальности ведущего узла в любой момент времени",
        "start": null,
        "end": null,
        "id": "unit_0016",
        "refined": "Гарантия уникальности ведущего узла в любой момент времени.",
        "summary": "Гарантируется, что в любой момент времени существует только один уникальный ведущий узел.",
        "topics": [
          "уникальность узла",
          "гарантия стабильности"
        ],
        "topics_en": [
          "node uniqueness",
          "stability guarantee"
        ]
      },
      {
        "text": "более слабую гарантию: протоколы определяют номер перио- да (в Paxos называемый номером бюллетеня, в Viewstamped Replication — номером просмотра, в Raft — номером термина) и гарантируют, что в каждый период веду- щий узел уникален.",
        "start": null,
        "end": null,
        "id": "unit_0017",
        "refined": "более слабую гарантию: протоколы определяют номер периода (в Paxos — номер бюллетеня, в Viewstamped Replication — номер просмотра, в Raft — номер термина) и гарантируют уникальность ведущего узла в каждом периоде.",
        "summary": "Протоколы обеспечивают уникальность ведущего узла в каждом периоде, используя номера бюллетеней, просмотров или терминов.",
        "topics": [
          "номер периода",
          "гарантия уникальности",
          "ведущий узел"
        ],
        "topics_en": [
          "period number",
          "uniqueness guarantee",
          "leader node"
        ]
      },
      {
        "text": "Большинство консенсусных алгоритмов предполагает, что в голосовании уча- ствует фиксированный набор узлов.",
        "start": 2173,
        "end": 2280,
        "id": "unit_0018",
        "refined": "Большинство консенсусных алгоритмов предполагает участие фиксированного набора узлов в голосовании.",
        "summary": "Большинство консенсусных алгоритмов основывается на голосовании фиксированного набора узлов.",
        "topics": [
          "консенсусные алгоритмы",
          "фиксированный набор узлов"
        ],
        "topics_en": [
          "consensus algorithms",
          "fixed node set"
        ]
      },
      {
        "text": "То есть нельзя просто добавить или удалить узел в кластере.",
        "start": 2281,
        "end": 2340,
        "id": "unit_0019",
        "refined": "Нельзя просто добавлять или удалять узлы в кластере.",
        "summary": "В кластере нельзя просто добавлять или удалять узлы без последствий.",
        "topics": [
          "управление кластером",
          "изменение конфигурации"
        ],
        "topics_en": [
          "cluster management",
          "configuration change"
        ]
      },
      {
        "text": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять набор узлов в кластере, но они гораздо менее понятны, чем алгоритмы статического членства.",
        "start": 2341,
        "end": 2510,
        "id": "unit_0020",
        "refined": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять состав узлов в кластере, но они менее понятны, чем алгоритмы статического членства.",
        "summary": "Расширения динамического членства в консенсусных алгоритмах обеспечивают гибкость в изменении состава узлов, но усложняют понимание процесса.",
        "topics": [
          "динамическое членство",
          "консенсусные алгоритмы",
          "изменение состава",
          "статическое членство"
        ],
        "topics_en": [
          "dynamic membership",
          "consensus algorithms",
          "composition change",
          "static membership"
        ]
      },
      {
        "text": "Система ZooKeeper смоделирована после сервиса блокировки Google Chubby [14, 98].",
        "start": 2511,
        "end": 2591,
        "id": "unit_0021",
        "refined": "Система ZooKeeper основана на сервисе блокировки Google Chubby [14, 98].",
        "summary": "Система ZooKeeper, как и сервис блокировки Google Chubby, обеспечивает координацию между процессами в распределённых системах.",
        "topics": [
          "ZooKeeper",
          "Google Chubby",
          "сервис блокировки"
        ],
        "topics_en": [
          "ZooKeeper",
          "Google Chubby",
          "locking service"
        ]
      },
      {
        "text": "В ней реализована не только рассылка общей последовательности",
        "start": 2592,
        "end": 2655,
        "id": "unit_0022",
        "refined": "В ней реализована рассылка общей последовательности.",
        "summary": "В системе внедрена функция рассылки общей последовательности.",
        "topics": [
          "рассылка последовательности"
        ],
        "topics_en": [
          "sequence distribution"
        ]
      },
      {
        "text": "проблем фактически сводится к консенсусу, они эквивалентны (в том смысле, что если есть решение для одной из них, то его можно легко превратить в таковое для остальных).",
        "start": 2656,
        "end": 2826,
        "id": "unit_0023",
        "refined": "Проблемы фактически сводятся к консенсусу и эквивалентны: решение одной проблемы легко превращается в решение остальных.",
        "summary": "Проблемы взаимосвязаны и эквивалентны, так как решение одной автоматически решает остальные через достижение консенсуса.",
        "topics": [
          "консенсус проблем",
          "эквивалентные проблемы",
          "решение проблем"
        ],
        "topics_en": [
          "consensus issues",
          "equivalent issues",
          "problem solutions"
        ]
      },
      {
        "text": "К таким эквивалентным проблемам относятся следующие.\nЛинейные реестры сравнения с присвоением.",
        "start": 2827,
        "end": 2924,
        "id": "unit_0024",
        "refined": "К таким эквивалентным проблемам относятся: - Линейные реестры сравнения с присвоением.",
        "summary": "Эквивалентные проблемы включают линейные реестры сравнения с присвоением.",
        "topics": [
          "Линейные реестры сравнения"
        ],
        "topics_en": [
          "Linear comparison registers"
        ]
      },
      {
        "text": "Реестр должен атомарно принять решение, присваивать ли значение в зависимости от того, соответствует ли его текущее значение параметру, указанному в операции.\nАтомарная транзакция.",
        "start": 2925,
        "end": 3107,
        "id": "unit_0025",
        "refined": "Реестр должен атомарно решить, присваивать ли значение, исходя из соответствия текущего значения параметру, указанному в операции. Атомарная транзакция.",
        "summary": "Реестр атомарно решает, присваивать ли значение, проверяя соответствие текущего значения параметру из операции, обеспечивая целостность транзакции.",
        "topics": [
          "атомарная транзакция",
          "присвоение значения",
          "проверка соответствия",
          "операция реестра"
        ],
        "topics_en": [
          "atomic transaction",
          "value assignment",
          "compliance check",
          "registry operation"
        ]
      },
      {
        "text": "База данных должна принять решение, следует ли за- вершать или отменить распределенную транзакцию.\nРассылка общей последовательности.",
        "start": 3108,
        "end": 3244,
        "id": "unit_0026",
        "refined": "База данных должна решить, завершать или отменять распределенную транзакцию. Рассылка общей последовательности.",
        "summary": "База данных определяет, завершать или отменять распределенную транзакцию, и рассылает общую последовательность команд.",
        "topics": [
          "распределенная транзакция",
          "база данных",
          "рассылка последовательности"
        ],
        "topics_en": [
          "distributed transaction",
          "database",
          "sequence broadcasting"
        ]
      },
      {
        "text": "Система обмена сообщениями должна принять решение о последовательности доставки сообщений.\nБлокировки и аренда.",
        "start": 3245,
        "end": 3359,
        "id": "unit_0027",
        "refined": "Система обмена сообщениями должна определить порядок их доставки. Блокировки и аренда.",
        "summary": "Система обмена сообщениями должна определить порядок доставки, учитывая блокировки и аренду.",
        "topics": [
          "порядок доставки сообщений",
          "блокировки аренда"
        ],
        "topics_en": [
          "message delivery order",
          "lock leasing"
        ]
      },
      {
        "text": "Когда несколько клиентов ратуют за блокировку или ее отмену, блокировка принимает решение о том, какой из них выбрать.\nСервис членства и координации.",
        "start": 3360,
        "end": 3512,
        "id": "unit_0028",
        "refined": "Когда несколько клиентов требуют блокировку или ее снятие, система выбирает одного из них. Сервис членства и координации.",
        "summary": "Система выбирает одного клиента для выполнения запроса на блокировку или снятие блокировки среди нескольких, используя сервис членства и координации.",
        "topics": [
          "блокировка клиентов",
          "выбор клиента",
          "сервис координации",
          "членство сервиса"
        ],
        "topics_en": [
          "client blocking",
          "client selection",
          "coordination service",
          "service membership"
        ]
      },
      {
        "text": "Основываясь на детекторе отказа (например, времени задержки), система должна принять решение, какие узлы активны, а какие следует считать вышедшими из строя, потому что их сеансы были от- ключены.\nОграничение уникальности.",
        "start": 3513,
        "end": 3737,
        "id": "unit_0029",
        "refined": "Система должна определить активные узлы и выявить отказавшие, основываясь на детекторе отказа, например, времени задержки.",
        "summary": "Система использует детектор отказа, например, время задержки, для выявления активных и неисправных узлов.",
        "topics": [
          "активные узлы",
          "детектор отказа",
          "время задержки"
        ],
        "topics_en": [
          "active nodes",
          "failure detector",
          "delay time"
        ]
      },
      {
        "text": "Когда несколько транзакций конкурентно пытаются создать конфликтующие записи с одним и тем же ключом, ограничение должно принять решение, какую из них разрешить, а какие — отменить по причине на- рушения ограничения.",
        "start": 3738,
        "end": 3955,
        "id": "unit_0030",
        "refined": "При конкурентном создании нескольких транзакций с одинаковым ключом ограничение должно решить, какую транзакцию разрешить, а какие отменить из-за нарушения ограничения.",
        "summary": "При создании нескольких конкурентных транзакций с одинаковым ключом ограничение определяет, какую транзакцию принять, а какие отклонить.",
        "topics": [
          "Конкурентное создание транзакций",
          "Одинаковый ключ",
          "Решение ограничения",
          "Нарушение ограничения"
        ],
        "topics_en": [
          "Competitive transaction creation",
          "Duplicate key",
          "Constraint resolution",
          "Constraint violation"
        ]
      },
      {
        "text": "Временные метки Лампорта",
        "start": null,
        "end": null,
        "id": "unit_0031",
        "refined": "Временные метки Лампорта.",
        "summary": "Временные метки Лампорта используются для упорядочивания событий в распределённых системах, обеспечивая согласованность и последовательность операций.",
        "topics": [
          "Временные метки",
          "Лампорта"
        ],
        "topics_en": [
          "Timestamps",
          "Lamport"
        ]
      },
      {
        "text": "Линеаризуемость, и более слабая причинность",
        "start": null,
        "end": null,
        "id": "unit_0032",
        "refined": "Линеаризуемость и более слабая причинность.",
        "summary": "Линеаризуемость обеспечивает сильные гарантии порядка операций, в то время как причинность позволяет более гибкое их выполнение, сохраняя логическую последовательность.",
        "topics": [
          "Линеаризуемость",
          "Слабая причинность"
        ],
        "topics_en": [
          "Linearizability",
          "Weak Causality"
        ]
      },
      {
        "text": "линеаризуемость — популярную модель согласован- ности: ее цель состоит в том, чтобы реплицированные данные выглядели так, как будто существует только одна копия и все операции воздействуют на нее атомарно.",
        "start": null,
        "end": null,
        "id": "unit_0033",
        "refined": "Линеаризуемость — популярная модель согласованности, при которой реплицированные данные выглядят так, как если бы существовала только одна копия, и все операции выполнялись атомарно.",
        "summary": "Линеаризуемость — модель согласованности, при которой реплицированные данные выглядят как одна копия, и все операции выполняются атомарно.",
        "topics": [
          "Линеаризуемость",
          "Модель согласованности",
          "Реплицированные данные",
          "Атомарные операции"
        ],
        "topics_en": [
          "Linearizability",
          "Consistency model",
          "Replicated data",
          "Atomic operations"
        ]
      },
      {
        "text": "причинность, которая требует соблюдения последова- тельности событий в системе (что произошло раньше, а что позже, на основании причинно-следственных взаимосвязей).",
        "start": 4232,
        "end": 4398,
        "id": "unit_0034",
        "refined": "Причинность требует соблюдения последовательности событий в системе, основанной на причинно-следственных связях.",
        "summary": "Причинность обеспечивает последовательный порядок событий, основанный на их взаимных причинно-следственных отношениях.",
        "topics": [
          "Причинность",
          "Соблюдение последовательности",
          "События системы",
          "Причинно-следственные связи"
        ],
        "topics_en": [
          "Causality",
          "Sequence preservation",
          "System events",
          "Cause-effect relationships"
        ]
      },
      {
        "text": "В отличие от линеаризуемости, выстраи- вающей все операции в единую, полностью упорядоченную временную последо- вательность, причинность позволяет построить более слабую модель согласован- ности: отдельные события могут быть конкурентными, как в истории версий с ее ветвлениями и слияниями.",
        "start": 4399,
        "end": 4691,
        "id": "unit_0035",
        "refined": "В отличие от линеаризуемости, которая выстраивает все операции в единую, полностью упорядоченную временную последовательность, причинность позволяет построить более слабую модель согласованности, где отдельные события могут быть конкурентными, как в истории версий с её ветвлениями и слияниями.",
        "summary": "В то время как линеаризуемость требует полной временной упорядоченности всех операций, причинность допускает конкурентные события, как в ветвящихся и сливаемых историях версий.",
        "topics": [
          "линеаризуемость операций",
          "причинность событий",
          "модель согласованности",
          "ветвления слияния"
        ],
        "topics_en": [
          "linearizability operations",
          "causality events",
          "consistency model",
          "branching merging"
        ]
      },
      {
        "text": "Причинная согласованность не несет накладных рас- ходов на линеаризуемость и гораздо менее чувствительна к сетевым проблемам.",
        "start": 4692,
        "end": 4817,
        "id": "unit_0036",
        "refined": "Причинная согласованность не требует дополнительных затрат на линеаризуемость и менее чувствительна к сетевым проблемам.",
        "summary": "Причинная согласованность экономит ресурсы и устойчива к сетевым сбоям, не требуя дополнительных затрат на линеаризуемость.",
        "topics": [
          "причинная согласованность",
          "сетевые проблемы",
          "дополнительные затраты"
        ],
        "topics_en": [
          "causal consistency",
          "network issues",
          "additional costs"
        ]
      },
      {
        "text": "этой формулировке консенсусный алгоритм должен удовлетворять следующим требованиям [25]1.\nЕдиное решение.",
        "start": 4818,
        "end": 4925,
        "id": "unit_0037",
        "refined": "Консенсусный алгоритм должен удовлетворять требованию единого решения [25].",
        "summary": "Консенсусный алгоритм обязан обеспечивать единое решение для всех участников процесса.",
        "topics": [
          "единого решения",
          "консенсусный алгоритм"
        ],
        "topics_en": [
          "single solution",
          "consensus algorithm"
        ]
      },
      {
        "text": "Никакие два узла не могут получить разные решения.\nЦелостность.",
        "start": 4926,
        "end": 4991,
        "id": "unit_0038",
        "refined": "Никакие два узла не могут получить разные решения. Целостность.",
        "summary": "Целостность системы обеспечивает, что никакие два узла не получают противоречивые решения.",
        "topics": [
          "Целостность системы",
          "Узлы решения"
        ],
        "topics_en": [
          "System Integrity",
          "Decision Nodes"
        ]
      },
      {
        "text": "Ни один узел не получает два решения.\nДействительность.",
        "start": 4992,
        "end": 5049,
        "id": "unit_0039",
        "refined": "Ни один узел не получает два решения.",
        "summary": "Каждый узел получает только одно решение.",
        "topics": [
          "уникальные решения",
          "узел системы"
        ],
        "topics_en": [
          "unique solutions",
          "system node"
        ]
      },
      {
        "text": "Если узел выбирает решение v, то v было предложено дру- гим узлом.\nЗавершенность.",
        "start": 5050,
        "end": 5133,
        "id": "unit_0040",
        "refined": "Если узел выбирает решение v, то v было предложено другим узлом. Завершенность.",
        "summary": "Если узел выбирает решение v, оно обязательно было предложено другим узлом, что обеспечивает завершенность процесса.",
        "topics": [
          "Выбор решения",
          "Предложение узлом",
          "Завершенность процесса"
        ],
        "topics_en": [
          "Decision making",
          "Node proposal",
          "Process completion"
        ]
      },
      {
        "text": "Каждый узел, который не вышел из строя, в конечном итоге выбирает то или иное значение.",
        "start": 5134,
        "end": 5221,
        "id": "unit_0041",
        "refined": "Каждый работающий узел в итоге выбирает значение.",
        "summary": "Каждый активный узел в системе最终选择一个值. Note: The last part of the sentence \"最终选择一个值\" is in Chinese, which means \"eventually chooses a value\". The correct Russian translation should be \"в конечном итоге выбирает значение\". Here is the corrected version: Каждый активный узел в системе в конечном итоге выбирает значение.",
        "topics": [
          "Выбор значения",
          "Работающие узлы"
        ],
        "topics_en": [
          "Value selection",
          "Active nodes"
        ]
      },
      {
        "text": "Завершенность — свойство жизнеспособности, в то время как остальные три являются свойствами безопасно- сти, см. пункт «Функциональная безопасность и живучесть» подраздела «Модели системы на практике» раздела 8.4.",
        "start": null,
        "end": null,
        "id": "unit_0042",
        "refined": "Завершенность — свойство жизнеспособности, в то время как остальные три свойства относятся к безопасности. См. пункт «Функциональная безопасность и живучесть» в подразделе «Модели системы на практике» раздела 8.4.",
        "summary": "Завершенность обеспечивает жизнеспособность системы, в то время как другие свойства относятся к её безопасности.",
        "topics": [
          "Завершенность жизнеспособности",
          "Функциональная безопасность",
          "Система практике"
        ],
        "topics_en": [
          "Viability completeness",
          "Functional safety",
          "Practice system"
        ]
      },
      {
        "text": "Наиболее известными отказоустойчивыми консенсусными алгоритмами явля- ются Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
        "start": null,
        "end": null,
        "id": "unit_0043",
        "refined": "Наиболее известные отказоустойчивые консенсусные алгоритмы: Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
        "summary": "Известные отказоустойчивые консенсусные алгоритмы включают Viewstamped Replication, Paxos, Raft и Zab, обеспечивающие согласованность данных в распределённых системах.",
        "topics": [
          "Отказоустойчивые алгоритмы",
          "Viewstamped Replication",
          "Paxos",
          "Raft"
        ],
        "topics_en": [
          "Fault-tolerant algorithms",
          "Viewstamped Replication",
          "Paxos",
          "Raft"
        ]
      },
      {
        "text": "Алгоритм рассылки общей последовательности",
        "start": null,
        "end": null,
        "id": "unit_0044",
        "refined": "Алгоритм рассылки общей последовательности:.",
        "summary": "Алгоритм рассылки общей последовательности обеспечивает эффективное распространение данных среди участников системы.",
        "topics": [
          "рассылка последовательности",
          "общая последовательность"
        ],
        "topics_en": [
          "sequence distribution",
          "shared sequence"
        ]
      },
      {
        "text": "Гарантия уникальности ведущего узла в любой момент времени",
        "start": null,
        "end": null,
        "id": "unit_0045",
        "refined": "Гарантия уникальности ведущего узла в любой момент времени.",
        "summary": "Гарантируется, что в любой момент времени существует только один уникальный ведущий узел.",
        "topics": [
          "уникальность узла",
          "гарантия стабильности"
        ],
        "topics_en": [
          "node uniqueness",
          "stability guarantee"
        ]
      },
      {
        "text": "более слабую гарантию: протоколы определяют номер перио- да (в Paxos называемый номером бюллетеня, в Viewstamped Replication — номером просмотра, в Raft — номером термина) и гарантируют, что в каждый период веду- щий узел уникален.",
        "start": null,
        "end": null,
        "id": "unit_0046",
        "refined": "более слабую гарантию: протоколы определяют номер периода (в Paxos — номер бюллетеня, в Viewstamped Replication — номер просмотра, в Raft — номер термина) и гарантируют уникальность ведущего узла в каждом периоде.",
        "summary": "Протоколы обеспечивают уникальность ведущего узла в каждом периоде, используя номера бюллетеней, просмотров или терминов.",
        "topics": [
          "номер периода",
          "гарантия уникальности",
          "ведущий узел"
        ],
        "topics_en": [
          "period number",
          "uniqueness guarantee",
          "leader node"
        ]
      },
      {
        "text": "Большинство консенсусных алгоритмов предполагает, что в голосовании уча- ствует фиксированный набор узлов.",
        "start": 5944,
        "end": 6051,
        "id": "unit_0047",
        "refined": "Большинство консенсусных алгоритмов предполагает участие фиксированного набора узлов в голосовании.",
        "summary": "Большинство консенсусных алгоритмов основывается на голосовании фиксированного набора узлов.",
        "topics": [
          "консенсусные алгоритмы",
          "фиксированный набор узлов"
        ],
        "topics_en": [
          "consensus algorithms",
          "fixed node set"
        ]
      },
      {
        "text": "То есть нельзя просто добавить или удалить узел в кластере.",
        "start": 6052,
        "end": 6111,
        "id": "unit_0048",
        "refined": "Нельзя просто добавлять или удалять узлы в кластере.",
        "summary": "В кластере нельзя просто добавлять или удалять узлы без последствий.",
        "topics": [
          "управление кластером",
          "изменение конфигурации"
        ],
        "topics_en": [
          "cluster management",
          "configuration change"
        ]
      },
      {
        "text": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять набор узлов в кластере, но они гораздо менее понятны, чем алгоритмы статического членства.",
        "start": 6112,
        "end": 6281,
        "id": "unit_0049",
        "refined": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять состав узлов в кластере, но они менее понятны, чем алгоритмы статического членства.",
        "summary": "Расширения динамического членства в консенсусных алгоритмах обеспечивают гибкость в изменении состава узлов, но усложняют понимание процесса.",
        "topics": [
          "динамическое членство",
          "консенсусные алгоритмы",
          "изменение состава",
          "статическое членство"
        ],
        "topics_en": [
          "dynamic membership",
          "consensus algorithms",
          "composition change",
          "static membership"
        ]
      },
      {
        "text": "Система ZooKeeper смоделирована после сервиса блокировки Google Chubby [14, 98].",
        "start": 6282,
        "end": 6362,
        "id": "unit_0050",
        "refined": "Система ZooKeeper основана на сервисе блокировки Google Chubby [14, 98].",
        "summary": "Система ZooKeeper, как и сервис блокировки Google Chubby, обеспечивает координацию между процессами в распределённых системах.",
        "topics": [
          "ZooKeeper",
          "Google Chubby",
          "сервис блокировки"
        ],
        "topics_en": [
          "ZooKeeper",
          "Google Chubby",
          "locking service"
        ]
      },
      {
        "text": "В ней реализована не только рассылка общей последовательности",
        "start": 6363,
        "end": 6426,
        "id": "unit_0051",
        "refined": "В ней реализована рассылка общей последовательности.",
        "summary": "В системе внедрена функция рассылки общей последовательности.",
        "topics": [
          "рассылка последовательности"
        ],
        "topics_en": [
          "sequence distribution"
        ]
      },
      {
        "text": "проблем фактически сводится к консенсусу, они эквивалентны (в том смысле, что если есть решение для одной из них, то его можно легко превратить в таковое для остальных).",
        "start": 6427,
        "end": 6597,
        "id": "unit_0052",
        "refined": "Проблемы фактически сводятся к консенсусу и эквивалентны: решение одной проблемы легко превращается в решение остальных.",
        "summary": "Проблемы взаимосвязаны и эквивалентны, так как решение одной автоматически решает остальные через достижение консенсуса.",
        "topics": [
          "консенсус проблем",
          "эквивалентные проблемы",
          "решение проблем"
        ],
        "topics_en": [
          "consensus issues",
          "equivalent issues",
          "problem solutions"
        ]
      },
      {
        "text": "К таким эквивалентным проблемам относятся следующие.\nЛинейные реестры сравнения с присвоением.",
        "start": 6598,
        "end": 6695,
        "id": "unit_0053",
        "refined": "К таким эквивалентным проблемам относятся: - Линейные реестры сравнения с присвоением.",
        "summary": "Эквивалентные проблемы включают линейные реестры сравнения с присвоением.",
        "topics": [
          "Линейные реестры сравнения"
        ],
        "topics_en": [
          "Linear comparison registers"
        ]
      },
      {
        "text": "Реестр должен атомарно принять решение, присваивать ли значение в зависимости от того, соответствует ли его текущее значение параметру, указанному в операции.\nАтомарная транзакция.",
        "start": 6696,
        "end": 6878,
        "id": "unit_0054",
        "refined": "Реестр должен атомарно решить, присваивать ли значение, исходя из соответствия текущего значения параметру, указанному в операции. Атомарная транзакция.",
        "summary": "Реестр атомарно решает, присваивать ли значение, проверяя соответствие текущего значения параметру из операции, обеспечивая целостность транзакции.",
        "topics": [
          "атомарная транзакция",
          "присвоение значения",
          "проверка соответствия",
          "операция реестра"
        ],
        "topics_en": [
          "atomic transaction",
          "value assignment",
          "compliance check",
          "registry operation"
        ]
      },
      {
        "text": "База данных должна принять решение, следует ли за- вершать или отменить распределенную транзакцию.\nРассылка общей последовательности.",
        "start": 6879,
        "end": 7015,
        "id": "unit_0055",
        "refined": "База данных должна решить, завершать или отменять распределенную транзакцию. Рассылка общей последовательности.",
        "summary": "База данных определяет, завершать или отменять распределенную транзакцию, и рассылает общую последовательность команд.",
        "topics": [
          "распределенная транзакция",
          "база данных",
          "рассылка последовательности"
        ],
        "topics_en": [
          "distributed transaction",
          "database",
          "sequence broadcasting"
        ]
      },
      {
        "text": "Система обмена сообщениями должна принять решение о последовательности доставки сообщений.\nБлокировки и аренда.",
        "start": 7016,
        "end": 7130,
        "id": "unit_0056",
        "refined": "Система обмена сообщениями должна определить порядок их доставки. Блокировки и аренда.",
        "summary": "Система обмена сообщениями должна определить порядок доставки, учитывая блокировки и аренду.",
        "topics": [
          "порядок доставки сообщений",
          "блокировки аренда"
        ],
        "topics_en": [
          "message delivery order",
          "lock leasing"
        ]
      },
      {
        "text": "Когда несколько клиентов ратуют за блокировку или ее отмену, блокировка принимает решение о том, какой из них выбрать.\nСервис членства и координации.",
        "start": 7131,
        "end": 7283,
        "id": "unit_0057",
        "refined": "Когда несколько клиентов требуют блокировку или ее снятие, система выбирает одного из них. Сервис членства и координации.",
        "summary": "Система выбирает одного клиента для выполнения запроса на блокировку или снятие блокировки среди нескольких, используя сервис членства и координации.",
        "topics": [
          "блокировка клиентов",
          "выбор клиента",
          "сервис координации",
          "членство сервиса"
        ],
        "topics_en": [
          "client blocking",
          "client selection",
          "coordination service",
          "service membership"
        ]
      },
      {
        "text": "Основываясь на детекторе отказа (например, времени задержки), система должна принять решение, какие узлы активны, а какие следует считать вышедшими из строя, потому что их сеансы были от- ключены.\nОграничение уникальности.",
        "start": 7284,
        "end": 7508,
        "id": "unit_0058",
        "refined": "Система должна определить активные узлы и выявить отказавшие, основываясь на детекторе отказа, например, времени задержки.",
        "summary": "Система использует детектор отказа, например, время задержки, для выявления активных и неисправных узлов.",
        "topics": [
          "активные узлы",
          "детектор отказа",
          "время задержки"
        ],
        "topics_en": [
          "active nodes",
          "failure detector",
          "delay time"
        ]
      },
      {
        "text": "Когда несколько транзакций конкурентно пытаются создать конфликтующие записи с одним и тем же ключом, ограничение должно принять решение, какую из них разрешить, а какие — отменить по причине на- рушения ограничения.",
        "start": 7509,
        "end": 7726,
        "id": "unit_0059",
        "refined": "При конкурентном создании нескольких транзакций с одинаковым ключом ограничение должно решить, какую транзакцию разрешить, а какие отменить из-за нарушения ограничения.",
        "summary": "При создании нескольких конкурентных транзакций с одинаковым ключом ограничение определяет, какую транзакцию принять, а какие отклонить.",
        "topics": [
          "Конкурентное создание транзакций",
          "Одинаковый ключ",
          "Решение ограничения",
          "Нарушение ограничения"
        ],
        "topics_en": [
          "Competitive transaction creation",
          "Duplicate key",
          "Constraint resolution",
          "Constraint violation"
        ]
      },
      {
        "text": "Временные метки Лампорта",
        "start": null,
        "end": null,
        "id": "unit_0060",
        "refined": "Временные метки Лампорта.",
        "summary": "Временные метки Лампорта используются для упорядочивания событий в распределённых системах, обеспечивая согласованность и последовательность операций.",
        "topics": [
          "Временные метки",
          "Лампорта"
        ],
        "topics_en": [
          "Timestamps",
          "Lamport"
        ]
      },
      {
        "text": "Линеаризуемость, и более слабая причинность",
        "start": null,
        "end": null,
        "id": "unit_0061",
        "refined": "Линеаризуемость и более слабая причинность.",
        "summary": "Линеаризуемость обеспечивает сильные гарантии порядка операций, в то время как причинность позволяет более гибкое их выполнение, сохраняя логическую последовательность.",
        "topics": [
          "Линеаризуемость",
          "Слабая причинность"
        ],
        "topics_en": [
          "Linearizability",
          "Weak Causality"
        ]
      },
      {
        "text": "линеаризуемость — популярную модель согласован- ности: ее цель состоит в том, чтобы реплицированные данные выглядели так, как будто существует только одна копия и все операции воздействуют на нее атомарно.",
        "start": null,
        "end": null,
        "id": "unit_0062",
        "refined": "Линеаризуемость — популярная модель согласованности, при которой реплицированные данные выглядят так, как если бы существовала только одна копия, и все операции выполнялись атомарно.",
        "summary": "Линеаризуемость — модель согласованности, при которой реплицированные данные выглядят как одна копия, и все операции выполняются атомарно.",
        "topics": [
          "Линеаризуемость",
          "Модель согласованности",
          "Реплицированные данные",
          "Атомарные операции"
        ],
        "topics_en": [
          "Linearizability",
          "Consistency model",
          "Replicated data",
          "Atomic operations"
        ]
      },
      {
        "text": "причинность, которая требует соблюдения последова- тельности событий в системе (что произошло раньше, а что позже, на основании причинно-следственных взаимосвязей).",
        "start": 8003,
        "end": 8169,
        "id": "unit_0063",
        "refined": "Причинность требует соблюдения последовательности событий в системе, основанной на причинно-следственных связях.",
        "summary": "Причинность обеспечивает последовательный порядок событий, основанный на их взаимных причинно-следственных отношениях.",
        "topics": [
          "Причинность",
          "Соблюдение последовательности",
          "События системы",
          "Причинно-следственные связи"
        ],
        "topics_en": [
          "Causality",
          "Sequence preservation",
          "System events",
          "Cause-effect relationships"
        ]
      },
      {
        "text": "В отличие от линеаризуемости, выстраи- вающей все операции в единую, полностью упорядоченную временную последо- вательность, причинность позволяет построить более слабую модель согласован- ности: отдельные события могут быть конкурентными, как в истории версий с ее ветвлениями и слияниями.",
        "start": 8170,
        "end": 8462,
        "id": "unit_0064",
        "refined": "В отличие от линеаризуемости, которая выстраивает все операции в единую, полностью упорядоченную временную последовательность, причинность позволяет построить более слабую модель согласованности, где отдельные события могут быть конкурентными, как в истории версий с её ветвлениями и слияниями.",
        "summary": "В то время как линеаризуемость требует полной временной упорядоченности всех операций, причинность допускает конкурентные события, как в ветвящихся и сливаемых историях версий.",
        "topics": [
          "линеаризуемость операций",
          "причинность событий",
          "модель согласованности",
          "ветвления слияния"
        ],
        "topics_en": [
          "linearizability operations",
          "causality events",
          "consistency model",
          "branching merging"
        ]
      },
      {
        "text": "Причинная согласованность не несет накладных рас- ходов на линеаризуемость и гораздо менее чувствительна к сетевым проблемам.",
        "start": 8463,
        "end": 8588,
        "id": "unit_0065",
        "refined": "Причинная согласованность не требует дополнительных затрат на линеаризуемость и менее чувствительна к сетевым проблемам.",
        "summary": "Причинная согласованность экономит ресурсы и устойчива к сетевым сбоям, не требуя дополнительных затрат на линеаризуемость.",
        "topics": [
          "причинная согласованность",
          "сетевые проблемы",
          "дополнительные затраты"
        ],
        "topics_en": [
          "causal consistency",
          "network issues",
          "additional costs"
        ]
      },
      {
        "text": "Толерантность к человеческим ошибкам",
        "start": null,
        "end": null,
        "id": "unit_0066",
        "refined": "Толерантность к ошибкам человека.",
        "summary": "Толерантность к ошибкам человека означает способность системы или организации продолжать функционировать эффективно, несмотря на человеческие ошибки.",
        "topics": [
          "Толерантность ошибкам",
          "Человеческий фактор"
        ],
        "topics_en": [
          "Error tolerance",
          "Human factor"
        ]
      },
      {
        "text": "Минимизация необратимости",
        "start": null,
        "end": null,
        "id": "unit_0067",
        "refined": "Минимизация необратимых процессов.",
        "summary": "Минимизация необратимых процессов направлена на снижение потерь энергии и повышение эффективности систем.",
        "topics": [
          "Минимизация процессов",
          "Необратимые изменения"
        ],
        "topics_en": [
          "Process minimization",
          "Irreversible changes"
        ]
      },
      {
        "text": "Дифференциальный поток данных",
        "start": null,
        "end": null,
        "id": "unit_0068",
        "refined": "Дифференциальный поток данных — это метод обработки данных, при котором учитываются только изменения в данных, а не весь набор данных целиком.",
        "summary": "Дифференциальный поток данных обрабатывает только изменения в данных, а не весь набор, что повышает эффективность.",
        "topics": [
          "дифференциальный поток",
          "обработка данных",
          "учет изменений"
        ],
        "topics_en": [
          "differential flow",
          "data processing",
          "change tracking"
        ]
      },
      {
        "text": "Сквозной аргумент",
        "start": null,
        "end": null,
        "id": "unit_0069",
        "refined": "Сквозной аргумент: это основное утверждение или идея, которая проходит через весь текст или проект, связывая все его части в единое целое.",
        "summary": "Сквозной аргумент — это центральная идея, объединяющая все части текста или проекта в единое целое.",
        "topics": [
          "Сквозной аргумент",
          "Основное утверждение",
          "Связь частей"
        ],
        "topics_en": [
          "Through Argument",
          "Main Claim",
          "Part Connection"
        ]
      },
      {
        "text": "TCP соединение к базе, и транзакция на ней не могут защитить от повторной записи, и нужны уникальные сквозные идентификаторы операции через все системы, например, uuid операции",
        "start": null,
        "end": null,
        "id": "unit_0070",
        "refined": "TCP-соединение и транзакции в базе данных не защищают от повторной записи. Для этого необходимы уникальные сквозные идентификаторы операций, например UUID.",
        "summary": "Для предотвращения повторной записи в базе данных недостаточно TCP-соединения и транзакций; нужны уникальные идентификаторы операций, такие как UUID.",
        "topics": [
          "TCP-соединение",
          "транзакции базы",
          "повторная запись",
          "уникальные идентификаторы"
        ],
        "topics_en": [
          "TCP connection",
          "database transactions",
          "rewriting",
          "unique identifiers"
        ]
      }
    ],
    "composites": [
      {
        "id": "comp_hier_0000",
        "type": "composite_hier",
        "units": [
          "unit_0001",
          "unit_0002",
          "unit_0003",
          "unit_0004",
          "unit_0005",
          "unit_0006",
          "unit_0007",
          "unit_0008",
          "unit_0009",
          "unit_0010",
          "unit_0011",
          "unit_0012",
          "unit_0013",
          "unit_0014",
          "unit_0015",
          "unit_0016",
          "unit_0017",
          "unit_0018",
          "unit_0019",
          "unit_0020",
          "unit_0021",
          "unit_0022",
          "unit_0023",
          "unit_0024",
          "unit_0025",
          "unit_0026",
          "unit_0027",
          "unit_0028",
          "unit_0029",
          "unit_0030",
          "unit_0031",
          "unit_0032",
          "unit_0033",
          "unit_0034",
          "unit_0035",
          "unit_0036",
          "unit_0037",
          "unit_0038",
          "unit_0039",
          "unit_0040",
          "unit_0041",
          "unit_0042",
          "unit_0043",
          "unit_0044",
          "unit_0045",
          "unit_0046",
          "unit_0047",
          "unit_0048",
          "unit_0049",
          "unit_0050",
          "unit_0051",
          "unit_0052",
          "unit_0053",
          "unit_0054",
          "unit_0055",
          "unit_0056",
          "unit_0057",
          "unit_0058",
          "unit_0059",
          "unit_0060",
          "unit_0061",
          "unit_0062",
          "unit_0063",
          "unit_0064",
          "unit_0065",
          "unit_0066",
          "unit_0067",
          "unit_0068",
          "unit_0069",
          "unit_0070"
        ],
        "title": "Линеаризуемость и причинность в системах",
        "rollup": "Для обеспечения линеаризуемого чтения данных можно использовать журнал, где позиция сообщения определяет время его чтения, или синхронно обновляемые реплики. Консенсусные алгоритмы, такие как Paxos, Raft и Zab, обеспечивают уникальность ведущего узла и согласованность данных, решая задачи, эквивалентные консенсусу, например, порядок доставки сообщений или управление блокировками.",
        "topics": [
          "линеаризуемое чтение",
          "журнал сообщений",
          "синхронные реплики",
          "консенсусные алгоритмы",
          "уникальность узла",
          "согласованность данных"
        ],
        "topics_en": [
          "linearizable read",
          "message log",
          "synchronous replicas",
          "consensus algorithms"
        ],
        "span": [
          null,
          null
        ]
      }
    ]
  }
}