{
  "units": [
    {
      "id": "u00000",
      "text": "Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems 1st Edition\n\nLet's list several options that allow making reads linearizable.",
      "start_char": 0,
      "end_char": 259
    },
    {
      "id": "u00001",
      "text": "Можно последовательно читать через журнал, добавляя туда сообщение, считывая журнал и затем выполняя фактическое чтение после возврата сообщения.",
      "start_char": 259,
      "end_char": 533
    },
    {
      "id": "u00002",
      "text": "Таким образом, позиция сообщения в журнале определяет момент времени, когда происходит чтение.",
      "start_char": 533,
      "end_char": 715
    },
    {
      "id": "u00003",
      "text": "(Примерно так реализованы операции чтения в Quorum [16].)",
      "start_char": 715,
      "end_char": 809
    },
    {
      "id": "u00004",
      "text": ")\nЕсли журнал позволяет получить позицию последнего сообщения линеаризуемым способом, то можно запросить её, дождаться, пока вам будут доставлены все записи до этой позиции, а затем выполнить чтение.",
      "start_char": 809,
      "end_char": 1177
    },
    {
      "id": "u00005",
      "text": "(Данная идея лежит в основе операции sync() в ZooKeeper [15].)",
      "start_char": 1177,
      "end_char": 1270
    },
    {
      "id": "u00006",
      "text": ")\nМожно выполнить чтение реплики, которая синхронно обновляется при записи и, следовательно, наверняка будет актуальной.",
      "start_char": 1270,
      "end_char": 1492
    },
    {
      "id": "u00007",
      "text": "(Этот метод используется при цепной репликации [63]; см.)",
      "start_char": 1492,
      "end_char": 1591
    },
    {
      "id": "u00008",
      "text": "также врезку «Исследование вопроса репликации» в подразделе «Синхронная и асинхронная репликация» раздела 5.",
      "start_char": 1591,
      "end_char": 1794
    },
    {
      "id": "u00009",
      "text": "1.",
      "start_char": 1794,
      "end_char": 1796
    },
    {
      "id": "u00010",
      "text": "В этой формулировке консенсусный алгоритм должен удовлетворять следующим требованиям [25]: 1.",
      "start_char": 1796,
      "end_char": 1965
    },
    {
      "id": "u00011",
      "text": "Единое решение.",
      "start_char": 1965,
      "end_char": 1999
    },
    {
      "id": "u00012",
      "text": "Никакие два узла не могут получить различные решения.",
      "start_char": 1999,
      "end_char": 2092
    },
    {
      "id": "u00013",
      "text": "Целостность.",
      "start_char": 2092,
      "end_char": 2121
    },
    {
      "id": "u00014",
      "text": "Ни один узел не получает два решения.",
      "start_char": 2121,
      "end_char": 2189
    },
    {
      "id": "u00015",
      "text": "Действительность.",
      "start_char": 2189,
      "end_char": 2228
    },
    {
      "id": "u00016",
      "text": "Если узел выбирает решение v, то v было предложено другим узлом.",
      "start_char": 2228,
      "end_char": 2345
    },
    {
      "id": "u00017",
      "text": "Завершенность.",
      "start_char": 2345,
      "end_char": 2378
    },
    {
      "id": "u00018",
      "text": "Каждый узел, который не вышел из строя, в конечном итоге выбирает то или иное значение.",
      "start_char": 2378,
      "end_char": 2536
    },
    {
      "id": "u00019",
      "text": "Завершенность — свойство жизнеспособности, в то время как остальные три являются свойствами безопасности, см.",
      "start_char": 2536,
      "end_char": 2745
    },
    {
      "id": "u00020",
      "text": "пункт «Функциональная безопасность и живучесть» подраздела «Модели системы на практике» раздела 8.",
      "start_char": 2745,
      "end_char": 2929
    },
    {
      "id": "u00021",
      "text": "4.",
      "start_char": 2929,
      "end_char": 2931
    },
    {
      "id": "u00022",
      "text": "Наиболее известными отказоустойчивыми консенсусными алгоритмами являются Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
      "start_char": 2931,
      "end_char": 3177
    },
    {
      "id": "u00023",
      "text": "Алгоритм рассылки общей последовательности\n\nГарантия уникальности ведущего узла в любой момент времени\n\nболее слабую гарантию: протоколы определяют номер периода (в Paxos называемый номером бюллетеня, в Viewstamped Replication — номером просмотра, в Raft — номером термина) и гарантируют, что в каждый период ведущий узел уникален.",
      "start_char": 3177,
      "end_char": 3776
    },
    {
      "id": "u00024",
      "text": "Большинство консенсусных алгоритмов предполагает, что в голосовании участвует фиксированный набор узлов.",
      "start_char": 3776,
      "end_char": 3980
    },
    {
      "id": "u00025",
      "text": "То есть нельзя просто добавлять или удалять узлы в кластере.",
      "start_char": 3980,
      "end_char": 4089
    },
    {
      "id": "u00026",
      "text": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять состав узлов в кластере, но они гораздо менее понятны, чем алгоритмы статического членства.",
      "start_char": 4089,
      "end_char": 4405
    },
    {
      "id": "u00027",
      "text": "Система ZooKeeper смоделирована на основе сервиса блокировки Google Chubby [14, 98].",
      "start_char": 4405,
      "end_char": 4531
    },
    {
      "id": "u00028",
      "text": "В ней реализована не только рассылка общей последовательности.\n\nПроблемы фактически сводятся к консенсусу, они эквивалентны (в том смысле, что если есть решение для одной из них, то его можно легко превратить в решение для остальных).",
      "start_char": 4531,
      "end_char": 4963
    },
    {
      "id": "u00029",
      "text": "К таким эквивалентным проблемам относятся следующие.",
      "start_char": 4963,
      "end_char": 5062
    },
    {
      "id": "u00030",
      "text": "Линейные реестры сравнения с присвоением.",
      "start_char": 5062,
      "end_char": 5147
    },
    {
      "id": "u00031",
      "text": "Реестр должен атомарно принять решение о присвоении значения в зависимости от того, соответствует ли его текущее значение параметру, указанному в операции.",
      "start_char": 5147,
      "end_char": 5440
    },
    {
      "id": "u00032",
      "text": "Атомарная транзакция.",
      "start_char": 5440,
      "end_char": 5486
    },
    {
      "id": "u00033",
      "text": "База данных должна принять решение, следует ли завершать или отменить распределенную транзакцию.",
      "start_char": 5486,
      "end_char": 5668
    },
    {
      "id": "u00034",
      "text": "Рассылка общей последовательности.",
      "start_char": 5668,
      "end_char": 5741
    },
    {
      "id": "u00035",
      "text": "Система обмена сообщениями должна принять решение о последовательности доставки сообщений.",
      "start_char": 5741,
      "end_char": 5914
    },
    {
      "id": "u00036",
      "text": "Блокировки и аренда.",
      "start_char": 5914,
      "end_char": 5957
    },
    {
      "id": "u00037",
      "text": "Когда несколько клиентов ратуют за блокировку или ее отмену, решение о том, какой из них выбрать, принимает блокировка.",
      "start_char": 5957,
      "end_char": 6176
    },
    {
      "id": "u00038",
      "text": "Сервис членства и координации.",
      "start_char": 6176,
      "end_char": 6238
    },
    {
      "id": "u00039",
      "text": "Основываясь на детекторе отказа (например, времени задержки), система должна принять решение, какие узлы активны, а какие следует считать вышедшими из строя, так как их сеансы были отключены.",
      "start_char": 6238,
      "end_char": 6595
    },
    {
      "id": "u00040",
      "text": "Ограничение уникальности.",
      "start_char": 6595,
      "end_char": 6649
    },
    {
      "id": "u00041",
      "text": "Когда несколько транзакций конкурентно пытаются создать конфликтующие записи с одним и тем же ключом, ограничение должно принять решение, какую из них разрешить, а какие — отменить по причине нарушения ограничения.",
      "start_char": 6649,
      "end_char": 7050
    },
    {
      "id": "u00042",
      "text": "Временные метки Лампорта\n\nЛинеаризуемость, и более слабая причинность\n\nЛинеаризуемость — популярная модель согласованности: ее цель состоит в том, чтобы реплицированные данные выглядели так, как будто существует только одна копия, и все операции воздействуют на нее атомарно.",
      "start_char": 7050,
      "end_char": 7569
    },
    {
      "id": "u00043",
      "text": "причинность, которая требует соблюдения последовательности событий в системе (что произошло раньше, а что позже, на основе причинно-следственных связей).",
      "start_char": 7569,
      "end_char": 7879
    },
    {
      "id": "u00044",
      "text": "В отличие от линеаризуемости, выстраивающей все операции в единую, полностью упорядоченную временную последовательность, причинность позволяет построить более слабую модель согласованности: отдельные события могут быть конкурентными, как в истории версий с её ветвлениями и слияниями.",
      "start_char": 7879,
      "end_char": 8419
    },
    {
      "id": "u00045",
      "text": "Причинная согласованность не несёт накладных расходов на линеаризуемость и гораздо менее чувствительна к сетевым проблемам.",
      "start_char": 8419,
      "end_char": 8653
    },
    {
      "id": "u00046",
      "text": "В этой формулировке консенсусный алгоритм должен удовлетворять следующим требованиям [25]: 1.",
      "start_char": 8653,
      "end_char": 8821
    },
    {
      "id": "u00047",
      "text": "Единое решение.",
      "start_char": 8821,
      "end_char": 8855
    },
    {
      "id": "u00048",
      "text": "Никакие два узла не могут получить различные решения.",
      "start_char": 8855,
      "end_char": 8948
    },
    {
      "id": "u00049",
      "text": "Целостность.",
      "start_char": 8948,
      "end_char": 8977
    },
    {
      "id": "u00050",
      "text": "Ни один узел не получает два решения.",
      "start_char": 8977,
      "end_char": 9045
    },
    {
      "id": "u00051",
      "text": "Действительность.",
      "start_char": 9045,
      "end_char": 9084
    },
    {
      "id": "u00052",
      "text": "Если узел выбирает решение v, то v было предложено другим узлом.",
      "start_char": 9084,
      "end_char": 9201
    },
    {
      "id": "u00053",
      "text": "Завершенность.",
      "start_char": 9201,
      "end_char": 9234
    },
    {
      "id": "u00054",
      "text": "Каждый узел, который не вышел из строя, в конечном итоге выбирает то или иное значение.",
      "start_char": 9234,
      "end_char": 9392
    },
    {
      "id": "u00055",
      "text": "Завершенность — свойство жизнеспособности, в то время как остальные три являются свойствами безопасности, см.",
      "start_char": 9392,
      "end_char": 9601
    },
    {
      "id": "u00056",
      "text": "пункт «Функциональная безопасность и живучесть» подраздела «Модели системы на практике» раздела 8.",
      "start_char": 9601,
      "end_char": 9785
    },
    {
      "id": "u00057",
      "text": "4.",
      "start_char": 9785,
      "end_char": 9787
    },
    {
      "id": "u00058",
      "text": "Наиболее известными отказоустойчивыми консенсусными алгоритмами являются Viewstamped Replication (VSR) [94, 95], Paxos [96–99], Raft [22, 100, 101] и Zab [15, 21, 102].",
      "start_char": 9787,
      "end_char": 10033
    },
    {
      "id": "u00059",
      "text": "Алгоритм рассылки общей последовательности\n\nГарантия уникальности ведущего узла в любой момент времени\n\nболее слабую гарантию: протоколы определяют номер периода (в Paxos называемый номером бюллетеня, в Viewstamped Replication — номером просмотра, в Raft — номером термина) и гарантируют, что в каждый период ведущий узел уникален.",
      "start_char": 10033,
      "end_char": 10632
    },
    {
      "id": "u00060",
      "text": "Большинство консенсусных алгоритмов предполагает, что в голосовании участвует фиксированный набор узлов.",
      "start_char": 10632,
      "end_char": 10836
    },
    {
      "id": "u00061",
      "text": "То есть нельзя просто добавлять или удалять узлы в кластере.",
      "start_char": 10836,
      "end_char": 10945
    },
    {
      "id": "u00062",
      "text": "Расширения динамического членства в консенсусных алгоритмах позволяют изменять состав узлов в кластере, но они гораздо менее понятны, чем алгоритмы статического членства.",
      "start_char": 10945,
      "end_char": 11261
    },
    {
      "id": "u00063",
      "text": "Система ZooKeeper смоделирована на основе сервиса блокировки Google Chubby [14, 98].",
      "start_char": 11261,
      "end_char": 11387
    },
    {
      "id": "u00064",
      "text": "В ней реализована не только рассылка общей последовательности.\n\nПроблемы фактически сводятся к консенсусу, они эквивалентны (в том смысле, что если есть решение для одной из них, то его можно легко превратить в решение для остальных).",
      "start_char": 11387,
      "end_char": 11819
    },
    {
      "id": "u00065",
      "text": "К таким эквивалентным проблемам относятся следующие.",
      "start_char": 11819,
      "end_char": 11918
    },
    {
      "id": "u00066",
      "text": "Линейные реестры сравнения с присвоением.",
      "start_char": 11918,
      "end_char": 12003
    },
    {
      "id": "u00067",
      "text": "Реестр должен атомарно принять решение о присвоении значения в зависимости от того, соответствует ли его текущее значение параметру, указанному в операции.",
      "start_char": 12003,
      "end_char": 12296
    },
    {
      "id": "u00068",
      "text": "Атомарная транзакция.",
      "start_char": 12296,
      "end_char": 12342
    },
    {
      "id": "u00069",
      "text": "База данных должна принять решение, следует ли завершать или отменить распределенную транзакцию.",
      "start_char": 12342,
      "end_char": 12524
    },
    {
      "id": "u00070",
      "text": "Рассылка общей последовательности.",
      "start_char": 12524,
      "end_char": 12597
    },
    {
      "id": "u00071",
      "text": "Система обмена сообщениями должна принять решение о последовательности доставки сообщений.",
      "start_char": 12597,
      "end_char": 12770
    },
    {
      "id": "u00072",
      "text": "Блокировки и аренда.",
      "start_char": 12770,
      "end_char": 12813
    },
    {
      "id": "u00073",
      "text": "Когда несколько клиентов ратуют за блокировку или ее отмену, решение о том, какой из них выбрать, принимает блокировка.",
      "start_char": 12813,
      "end_char": 13032
    },
    {
      "id": "u00074",
      "text": "Сервис членства и координации.",
      "start_char": 13032,
      "end_char": 13094
    },
    {
      "id": "u00075",
      "text": "Основываясь на детекторе отказа (например, времени задержки), система должна принять решение, какие узлы активны, а какие следует считать вышедшими из строя, так как их сеансы были отключены.",
      "start_char": 13094,
      "end_char": 13451
    },
    {
      "id": "u00076",
      "text": "Ограничение уникальности.",
      "start_char": 13451,
      "end_char": 13505
    },
    {
      "id": "u00077",
      "text": "Когда несколько транзакций конкурентно пытаются создать конфликтующие записи с одним и тем же ключом, ограничение должно принять решение, какую из них разрешить, а какие — отменить по причине нарушения ограничения.",
      "start_char": 13505,
      "end_char": 13906
    },
    {
      "id": "u00078",
      "text": "Временные метки Лампорта\n\nЛинеаризуемость, и более слабая причинность\n\nЛинеаризуемость — популярная модель согласованности: ее цель состоит в том, чтобы реплицированные данные выглядели так, как будто существует только одна копия, и все операции воздействуют на нее атомарно.",
      "start_char": 13906,
      "end_char": 14425
    },
    {
      "id": "u00079",
      "text": "причинность, которая требует соблюдения последовательности событий в системе (что произошло раньше, а что позже, на основе причинно-следственных связей).",
      "start_char": 14425,
      "end_char": 14735
    },
    {
      "id": "u00080",
      "text": "В отличие от линеаризуемости, выстраивающей все операции в единую, полностью упорядоченную временную последовательность, причинность позволяет построить более слабую модель согласованности: отдельные события могут быть конкурентными, как в истории версий с её ветвлениями и слияниями.",
      "start_char": 14735,
      "end_char": 15275
    },
    {
      "id": "u00081",
      "text": "Причинная согласованность не несёт накладных расходов на линеаризуемость и гораздо менее чувствительна к сетевым проблемам.",
      "start_char": 15275,
      "end_char": 15509
    },
    {
      "id": "u00082",
      "text": "Толерантность к человеческим ошибкам\n\nМинимизация необратимости\n\nДифференциальный поток данных\n\nСквозной аргумент\n\nTCP-соединение к базе и транзакция на ней не могут защитить от повторной записи, поэтому нужны уникальные сквозные идентификаторы операции через все системы, например, UUID операции.",
      "start_char": 15509,
      "end_char": 16056
    }
  ],
  "composite": {
    "title": "Linearizable Reads in Distributed Systems",
    "summary": "The text discusses methods for achieving linearizable reads in distributed systems, such as reading through a journal, ensuring the read is performed after a message is returned, and reading from a synchronously updated replica. It also covers consensus algorithms like Paxos, Raft, and Zab, which ensure system reliability and consistency.",
    "topics": [
      {
        "text": "Методы линеаризуемых чтений в распределенных системах, такие как чтение через журнал, чтение после возврата сообщения и чтение из синхронно обновляемой реплики. Обсуждаются алгоритмы консенсуса, такие как Paxos, Raft и Zab, обеспечивающие надежность и согласованность системы.",
        "lang": "ru"
      },
      {
        "text": "Methods for achieving linearizable reads in distributed systems, such as reading through a journal, ensuring the read is performed after a message is returned, and reading from a synchronously updated replica. It also covers consensus algorithms like Paxos, Raft, and Zab, which ensure system reliability and consistency.",
        "lang": "en"
      }
    ]
  }
}